var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"DocTestSetup = quote\n  using Polynomials, SpecialPolynomials\nend","category":"page"},{"location":"examples/#Construction-1","page":"Examples","title":"Construction","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"This package provides several  types to represent  polynomials relative  to different  bases from the standard polynomial  basis, 1,x,x², x³ etc.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For example, the Legendre polynomials are a collection of polynomials on [-1,1]. The first few may be seen through:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> using Polynomials, SpecialPolynomials\n\njulia> p0 = Legendre([1])\nLegendre(1⋅P₀(x))\n\njulia> p1 = Legendre([0,1])\nLegendre(1⋅P₁(x))\n\njulia> p2 = Legendre([0,0,1])\nLegendre(1⋅P₂(x))\n\njulia> p3 = Legendre([0,0,0,1])\nLegendre(1⋅P₃(x))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The coefficients, e.g., [0,0,0,1] indicate a polynomial 0⋅p0 + 0⋅p1 + 0⋅p2 + 1⋅p3. The show method expresses these polynomials relative to their bases. More familiar expressions are seen by conversion to the standard basis. For example:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> convert.(Polynomial, [p0,p1,p2,p3])\n4-element Array{Polynomial,1}:\n Polynomial(1)\n Polynomial(1.0*x)\n Polynomial(-0.5 + 1.5*x^2)\n Polynomial(-1.5*x + 2.5*x^3)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Polynomial instances are callable. We have, for example, to evaluate a polynomial at a set of points:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> p3.([1/4, 1/2, 3/4])\n3-element Array{Float64,1}:\n -0.3359375\n -0.4375\n -0.0703125","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Conversion can also be achieved through polynomial evaluation, using a variable x in the Polynomial basis:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> x = variable(Polynomial)\nPolynomial(x)\n\njulia> p3(x)\nPolynomial(-1.5*x + 2.5*x^3)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Representation in another basis can be achieved this way:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> u = variable(ChebyshevU)\nChebyshevU(0.5⋅U₁(x))\n\njulia> p3(u)\nChebyshevU(- 0.125⋅U₁(x) + 0.3125⋅U₃(x))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For most of the orthogonal polynomials, a conversion from the standard basis is provided, and a conversion between different parameter values  for the  same polynomial type are provded. Conversion methods between other polynomial types are not provided, but either evaluation, as above, or conversion through the Polynomial type is possible.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For the basis functions, the basis function can be used:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> h0,h1,h2,h3 = basis.(Hermite, 0:3);\n\njulia> x = variable();\n\njulia> h3(x)\nPolynomial(-12.0*x + 8.0*x^3)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"If the coefficients are known, they can be directly passed to the constructor:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> Laguerre{0}([1,2,3])\nLaguerre{0}(1⋅L₀(x) + 2⋅L₁(x) + 3⋅L₂(x))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Some polynomial types are parameterized. The parameters are passed as in this example:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> Jacobi{1/2, -1/2}([1,2,3])\nJacobi{0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x) + 3⋅Jᵅᵝ₂(x))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The polynomial types specified above are orthogonal, meaning the inner product of different basis vectors will be 0. For example:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> using QuadGK\n\njulia> P = Legendre\nLegendre\n\njulia> p4,p5 = basis.(P, [4,5])\n2-element Array{Legendre{Float64,N} where N,1}:\n Legendre(1.0⋅P₄(x))\n Legendre(1.0⋅P₅(x))\n \njulia> wf, dom = SpecialPolynomials.weight_function(P), domain(P);\n\njulia> quadgk(x -> p4(x) * p5(x) *  wf(x), first(dom), last(dom))\n(-1.3877787807814457e-17, 0.0)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The unexported innerproduct will compute this as well, without the need to specifiy the domain or weight function, which can be gleaned from the type.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> SpecialPolynomials.innerproduct(P, p4, p5)\n-1.543670556388031e-16","category":"page"},{"location":"examples/#Polynomial-methods-1","page":"Examples","title":"Polynomial methods","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For each polynomial type, this package implements as many of the methods for polynomials defined in Polynomials, as possible. ","category":"page"},{"location":"examples/#Arithemtic-1","page":"Examples","title":"Arithemtic","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For example, basic arithmetic operations  are defined:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> P = ChebyshevU\nChebyshevU\n\njulia> p,q = P([1,2,3,4]), P([-2,0,1,2])\n(ChebyshevU(1⋅U_0(x) + 2⋅U_1(x) + 3⋅U_2(x) + 4⋅U_3(x)), ChebyshevU(- 2⋅U_0(x) + 1⋅U_2(x) + 2⋅U_3(x)))\n\njulia> p + 1\nChebyshevU(2⋅U_0(x) + 2⋅U_1(x) + 3⋅U_2(x) + 4⋅U_3(x))\n\njulia> -p\nChebyshevU(- 1⋅U_0(x) - 2⋅U_1(x) - 3⋅U_2(x) - 4⋅U_3(x))\n\njulia> p + q\nChebyshevU(- 1⋅U_0(x) + 2⋅U_1(x) + 4⋅U_2(x) + 6⋅U_3(x))\n\njulia> p*q\nChebyshevU(9⋅U_0(x) + 8⋅U_1(x) + 10⋅U_2(x) + 6⋅U_3(x) + 15⋅U_4(x) + 10⋅U_5(x) + 8⋅U_6(x))\n\njulia> p^2\nChebyshevU(30⋅U_0(x) + 40⋅U_1(x) + 51⋅U_2(x) + 44⋅U_3(x) + 41⋅U_4(x) + 24⋅U_5(x) + 16⋅U_6(x))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Multiplication formulas may not be defined for each type, and a fall back may be used where the multiplication is done with respect to the standard basis and the answer re-represented:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> P = Jacobi{1/2, -1/2}\nJacobi{0.5,-0.5,T,N} where N where T\n\njulia> p,q = P([1,2]), P([-2,1])\n(Jacobi{0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x)), Jacobi{0.5,-0.5}(- 2⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x)))\n\njulia> p * q\nJacobi{0.5,-0.5}(- 1.5⋅Jᵅᵝ₀(x) - 2.0⋅Jᵅᵝ₁(x) + 1.3333333333333333⋅Jᵅᵝ₂(x))","category":"page"},{"location":"examples/#Derivatives-and-integrals-1","page":"Examples","title":"Derivatives and integrals","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The classic continuous orthogonal polynomials  have  the derivative  and integrate methods defined:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> P = ChebyshevU{Float64}\nChebyshevU{Float64,N} where N\n\njulia> p = P([1,2,3])\nChebyshevU(1.0⋅U₀(x) + 2.0⋅U₁(x) + 3.0⋅U₂(x))\n\njulia> dp = derivative(p)\nChebyshevU(4.0⋅U₀(x) + 12.0⋅U₁(x))\n\njulia> convert.(Polynomial, (p, dp))\n(Polynomial(-2.0 + 4.0*x + 12.0*x^2), Polynomial(4.0 + 24.0*x))\n\njulia> P = Jacobi{1//2, -1//2}\nJacobi{1//2,-1//2,T,N} where N where T\n\njulia> p,q = P([1,2]), P([-2,1])\n(Jacobi{1//2,-1//2}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x)), Jacobi{1//2,-1//2}(- 2⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x)))\n\njulia> p * q # as above, only with rationals for paramters\nJacobi{1//2,-1//2}(- 1.5⋅Jᵅᵝ₀(x) - 2.0⋅Jᵅᵝ₁(x) + 1.3333333333333333⋅Jᵅᵝ₂(x))\n\njulia> P = Jacobi{1//2, 1//2}\nJacobi{1//2,1//2,T,N} where N where T\n\njulia> p = P([1,2,3])\nJacobi{1//2,1//2}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x) + 3⋅Jᵅᵝ₂(x))\n\njulia> dp = derivative(p)\nJacobi{1//2,1//2}(3.0⋅Jᵅᵝ₀(x) + 10.0⋅Jᵅᵝ₁(x))\n\njulia> integrate(p)\nJacobi{1//2,1//2}(0.375⋅Jᵅᵝ₀(x) + 0.24999999999999994⋅Jᵅᵝ₁(x) + 0.6⋅Jᵅᵝ₂(x) + 0.5714285714285714⋅Jᵅᵝ₃(x))\n\njulia> integrate(p, 0, 1)\n25//8","category":"page"},{"location":"examples/#Roots-1","page":"Examples","title":"Roots","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The roots function finds the roots of a polynomial ","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> p = Legendre([1,2,2,1])\nLegendre(1⋅P₀(x) + 2⋅P₁(x) + 2⋅P₂(x) + 1⋅P₃(x))\n\njulia> rts = roots(p)\n3-element Array{Float64,1}:\n -1.0\n -0.20000000000000007\n  0.0\n\njulia> p.(rts)\n3-element Array{Float64,1}:\n -2.220446049250313e-16\n  0.0\n  0.0","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Here we see fromroots and roots are related, provided a monic polynomial is used:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> using Polynomials, SpecialPolynomials; const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> P = Jacobi{1/2,-1/2}\nJacobi{0.5,-0.5,T,N} where N where T\n\n\njulia> p = P([1,1,2,3])\nJacobi{0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x) + 2⋅Jᵅᵝ₂(x) + 3⋅Jᵅᵝ₃(x))\n\njulia> q = SP.monic(p) # monic is not exported\nJacobi{0.5,-0.5}(0.13333333333333333⋅Jᵅᵝ₀(x) + 0.13333333333333333⋅Jᵅᵝ₁(x) + 0.26666666666666666⋅Jᵅᵝ₂(x) + 0.4⋅Jᵅᵝ₃(x))\n\njulia> fromroots(P, roots(q)) - q |> u -> truncate(u, atol=sqrt(eps())) \nJacobi{0.5,-0.5}(0.0)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The roots are found from the eigenvalues of the companion matrix, which may be directly produced  by companion; the default is  to find  it after conversion to the standard basis.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For orthogonal polynomials, the roots of the basis vectors are important for quadrature. For larger values of n, the eigenvalues of the unexported jacobi_matrix also identify these roots, but the algorithm is more stable.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> using LinearAlgebra\n\njulia> p5 = basis(Legendre, 5)\nLegendre(1.0⋅P₅(x))\n\njulia> roots(p5)\n5-element Array{Float64,1}:\n -0.9061798459386636\n -0.5384693101056829\n  0.538469310105683\n  0.9061798459386635\n  0.0\n\njulia> eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 5))\n5-element Array{Float64,1}:\n -0.906179845938664\n -0.5384693101056831\n -8.042985227174392e-17\n  0.5384693101056834\n  0.9061798459386639","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"At higher degrees, the difference in  stability comes out:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> p50 = basis(Legendre{Float64}, 50); sum(isreal.(roots(p50)))\n34\n\njulia> eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 50 ))  .|> isreal |> sum\n50","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"(The roots of the classic orthogonal polynomials  are  all  real  and distinct.)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The unexported gauss_nodes_weights function returns the nodes and weights. For many types (e.g., Jacobie, Legendre, Hermite, Laguerre) it uses an O(n) algorithm of Glaser, Liu, and Rokhlin, for others the O(n²) algorithm through the Jacobi matrix.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> xs, ys = SpecialPolynomials.gauss_nodes_weights(Legendre{Float64}, 10)\n([-0.9739065285171717, -0.8650633666889845, -0.6794095682990244, -0.4333953941292472, -0.1488743389816312, 0.1488743389816312, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717], [0.06667134430868804, 0.1494513491505808, 0.21908636251598188, 0.26926671930999635, 0.295524224714753, 0.295524224714753, 0.26926671930999635, 0.21908636251598188, 0.1494513491505808, 0.06667134430868804])","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"note: Note\nFor a broader and more robust implementation, the FastGaussQuadrature package provides O(n) algorithms for many classic orthogonal polynomial types.","category":"page"},{"location":"examples/#Fitting-1","page":"Examples","title":"Fitting","text":"","category":"section"},{"location":"examples/#Interpolation-1","page":"Examples","title":"Interpolation","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For any set of points (x0,y0), (x1,y1), ..., (xn, yn) with unique x values,  there is a unique polynomial of degree n or less that interpolates these points, that is  p(x_i) = y_i. The  fit function will perform polynomial interpolation:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> xs, ys = [0, 1/4,  1/2,  3/4], [1,2,2,3]\n([0.0, 0.25, 0.5, 0.75], [1, 2, 2, 3])\n\njulia> p1 = fit(Polynomial,  xs, ys)\nPolynomial(1.0000000000000002 + 8.66666666666669*x - 24.000000000000085*x^2 + 21.333333333333385*x^3)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The Lagrange and Newton types represent the polynomial in convenient bases based on the nodes (xs):","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> p2 = fit(Lagrange, xs, ys)\nLagrange(1⋅ℓ^3_0(x) + 2⋅ℓ^3_1(x) + 2⋅ℓ^3_2(x) + 3⋅ℓ^3_3(x))\n\njulia> p3 = fit(Newton, xs, ys)\nNewton(1.0⋅p_0(x) + 4.0⋅p_1(x) - 8.0⋅p_2(x) + 21.333333333333332⋅p_3(x))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"These all represent the same interpolating polynomial:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> [p1.(xs)-ys  p2.(xs)-ys p3.(xs)-ys]\n4×3 Array{Float64,2}:\n  2.22045e-16  0.0  0.0\n  1.33227e-15  0.0  0.0\n -3.33067e-15  0.0  0.0\n -8.88178e-15  0.0  0.0","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The Lagrange and Newton  methods allow a function to be specified  in place  of a set of y values:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> p = fit(Newton, [1,2,3], x->x^2)\nNewton(1.0⋅p_0(x) + 3.0⋅p_1(x) + 1.0⋅p_2(x))\n\njulia> convert(Polynomial, p)\nPolynomial(1.0*x^2)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Polynomial interpolation can demonstrate the Runge phenomenon if the nodes are evenly spaced. For higher degree fitting, the choice of nodes can greatly effect the approximation of the interpolating polynomial to the function generating the y values.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For an orthogonal polynomial type, the zeros of the basis polynomial p_{n+1}, labeled x_0, x_1, ..., x_n are often used as nodes, especially for the Chebyshev nodes (of the first kind).   Gil, Segura, and Temme say \"Interpolation with Chebyshev nodes is not as good as the best approximation ..., but usually it is the best practical possibility for interpolation and certainly much better than equispaced interpolation\"","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For the orthogonal polynomial types, the default for fit for degree n will use the zeros of P_{n+1} to interpolate. We can see that some interpolation points lead to better fits than others, in the following graphic:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"f(x) = exp(-x)*sinpi(x)\nplot(f, -1, 1, legend=false, color=:black, linewidth=3)\np=fit(Val(:interpolating), Chebyshev, f, 3);  plot!(p, color=:blue)\np=fit(Val(:interpolating), ChebyshevU, f, 3); plot!(p, color=:red)\nfit(Val(:interpolating), Legendre, f, 3);     plot!(p, color=:green)\nxs = [-0.5, 0.0, 0.5]\np=fit(Newton, xs, f);\nts = range(-1, 1, length=100);                plot!(ts, p.(ts), color=:brown)\nsavefig(\"fitting.svg\"); nothing # hide","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Polynomial-approximation-1","page":"Examples","title":"Polynomial approximation","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"There are other criteria for fitting that can be used.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"If there are a lot of points, it is common  to  fit with a  lower  degree polynomial. This won't  be an interpolating polynomial, in general. The criteria  used to select the polynomial is  typically least squares (weighted least squares is also available). Fitting  ini the standard basis, a  degree  is specified, as follows:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> xs, ys =  [1,2,3,4], [2.0,3,1,4]\n([1, 2, 3, 4], [2.0, 3.0, 1.0, 4.0])\n\njulia> p1 =  fit(Polynomial, xs,  ys, 1)  # degree 1  or less\nPolynomial(1.5 + 0.4*x)\n\njulia> p1 =  fit(Polynomial, xs,  ys, 2)  # degree 2 or less\nPolynomial(4.000000000000018 - 2.100000000000017*x + 0.5000000000000026*x^2)\n\njulia> p1 =  fit(Polynomial, xs,  ys)     # degree 3 or less (length(xs) - 1)\nPolynomial(-10.000000000000302 + 20.16666666666734*x - 9.500000000000297*x^2 + 1.3333333333333721*x^3)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For the orthogonal polynomial types, fitting a polynomial to a function using least squares can be solved using the polynomial a0⋅p0 + a1⋅p1 + ⋅⋅⋅ + an⋅pn where ai=∫f⋅pi⋅w⋅dx / ∫pi^2⋅w⋅dx. There is no need to specify values for x:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> f(x) = exp(-x) * sinpi(x)\nf (generic function with 1 method)\n\njulia> p = fit(Val(:lsq), Chebyshev{Float64}, f, 50);\n\njulia> maximum(norm(p(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps())\ntrue","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"This wavy example is from Trefethen:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> f(x) = sin(6x) + sin(60*exp(x))\nf (generic function with 1 method)\n\njulia> p50 = fit(Val(:lsq), Chebyshev{Float64}, f, 50);\n\njulia> maximum(norm(p50(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps()) # cf. graph below\nfalse","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"(With 50 points, the approximation misses badly over [-1,1]. There are 45 local extrema on  this interval.)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"However, with more points we have a good fit:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> p196 = fit(Chebyshev{Float64}, f, 196);\n\njulia> maximum(norm(p196(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps())  # ≈ 1e-13\ntrue","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials\nf(x) = sin(6x) + sin(60*exp(x))\np50 = fit(Chebyshev{Float64}, f, 50);\np196 = fit(Chebyshev{Float64}, f, 196);\nplot(f, -1, 1, legend=false, color=:black)\nxs = range(-1, stop=1, length=500) # more points than recipe\nplot!(xs, p50.(xs), color=:blue)\nplot!(xs, p196.(xs), color=:red)\nsavefig(\"wavy.svg\"); nothing # hide","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"For the  Chebyshev type, the  Val(:series) argument will fit a heuristically identify truncated series  to the function.","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Polynomials, SpecialPolynomials\nf(x) = sin(6x) + sin(60*exp(x))\np  = fit(Val(:series), Chebyshev, f);\ndegree(p)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"note: Note\nThe ApproxFun package provides a framework to quickly and accuratately approximate functions using certain polynomial types. The choice of order and methods for most of Julia's built-in functions are conveniently provided.","category":"page"},{"location":"examples/#Plotting-1","page":"Examples","title":"Plotting","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The plot recipe from the Polynomials package works as expected for the polynomial types in this package. The domain to be plotted over matches that given by domain, unless this is infinite. A plot of the first few Chebyshev Polynomials of the second kind can be produced as follows:","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials\n# U1, U2, U3, and U4:\nchebs = basis.(ChebyshevU, 1:4)\ncolors = [\"#4063D8\", \"#389826\", \"#CB3C33\", \"#9558B2\"]\nitr = zip(chebs, colors)\n(cheb,col), state = iterate(itr)\np = plot(cheb, c=col,  lw=5, legend=false, label=\"\")\nfor (cheb, col) in Base.Iterators.rest(itr, state)\n  plot!(cheb, c=col, lw=5)\nend\nsavefig(\"chebs.svg\"); nothing # hide","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#SpecialPolynomials.jl-1","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Documentation for SpecialPolynomials.jl.","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"CurrentModule = SpecialPolynomials","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"DocTestSetup = quote\n  using Polynomials, SpecialPolynomials\nend","category":"page"},{"location":"#Overview-1","page":"SpecialPolynomials.jl","title":"Overview","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"This package provides a number of different polynomial types to represent polynomials, extending the Polynomials package.","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractSpecialPolynomial","category":"page"},{"location":"#SpecialPolynomials.AbstractSpecialPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractSpecialPolynomial","text":"AbstractSpecialPolynomial{T}\n\nAn abstract type to distinguish the different polynomial types in this package.\n\nThe concrete types specify different bases for the space of polynomials of degree n or less. \n\nThis package includes: \n\nseveral classic orthogonal polynomials.\nNewton and Lagrange interpolating polynomials\nBernstein polynomials\n\nAs many of the methods for the base Polynomials class are directly coded if possible, but quite a few depend on conversion to the base Polynomial type (which uses the standard polynomial basis).\n\n\n\n\n\n","category":"type"},{"location":"#Orthogonal-polynomials-1","page":"SpecialPolynomials.jl","title":"Orthogonal polynomials","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractOrthogonalPolynomial\nSpecialPolynomials.AbstractCCOP\nSpecialPolynomials.AbstractCDOP","category":"page"},{"location":"#SpecialPolynomials.AbstractOrthogonalPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractOrthogonalPolynomial","text":"AbstractOrthogonalPolynomial{T}\n\nType to represent systems of orthogonal polynomials. These polynomials have  several properties, including an accompanying inner product satsifying  ⟨yᵢ, yⱼ⟩ = cᵢδᵢⱼ.\n\nIn addition to methods inherited from the underlying AbstractPolynomial  type, orthogonal polynomial  types may have methods   weight_function, generating_function, leading_term, norm2,jacobimatrix, andgaussnodes_weights`,  though none are  exported.\n\nSubtypes of AbstractCOP <: AbstractOrthogonalPolynomial utilize the fact that the basis  polynomials  satisfy\n\n(ax² + bx + c)yᵢ''(x) + (dx+e)yᵢ'(x) + λᵢyᵢ(x) = 0 (or a discrete analogue)\n\nwhere the structural relations are functions of a,b,c,d,e. These allow default definitions for polynomial evaluation,   addition, multiplication, differentiation, integration, and  conversion to and from  the Polynomial type (the FallingFactorial type in the discrete  c case),\n\nA key structural relation is the three-term recursion,  yᵢ₊₁ =  (Aᵢx +  Bᵢ)yᵢ -  Cᵢyᵢ₋₁. For systems  specfied by  a  weight function, the  values of Aᵢ, Bᵢ, and Cᵢ can  be  generated, yielding formulas for polynomial evaluation, addition, and conversion to the Polynomial  type throughe evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.AbstractCCOP","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractCCOP","text":"AbstractCCOP{T,N} <:  AbstractCOP{T,N}\n\nFollowing Koepf and Schmersau, a family y(x)=p_n(x)=k_x⋅x^n +  ...   for  n  ∈  {0, 1,…}, k_n ≠ 0 of polynomials is a family of classic continuous orthogonal polynomials if each is  a solution of the differential equation\n\n(a⋅x²+b⋅x+c) ⋅ yᵢ'' + (d⋅x + e) ⋅ yᵢ' + λᵢ⋅ yᵢ = 0.\n\nA family is characterized, up to choice of leading term, by the 5 coefficients: a,b,c,d,e. Let σ = (a⋅x²+b⋅x+c), τ = (d⋅x + e).\n\nFrom these  5  coefficients several structural  equations are represented. For example the three-point recusion.\n\nP₍ᵢ₊₁) = (Aᵢ⋅x + Bᵢ) * Pᵢ - Cᵢ *  P₍ᵢ₋₁₎,\n\nwhere Aᵢ,Bᵢ,Cᵢ can be represented in formulas involving just  a,b,c,d,e and i.\n\nRearranging   gives the structural equation:\n\nx⋅p_n   = [an, bn, cn] ⋅ [p_{n+1}, p_n, p_{n-1}]  (Eqn (7))\n\nThe other structural equations are (equation  references are from Koepf and Schmersau):\n\nσ⋅p'_n  = [αn, βn, γn] ⋅  [p_{n+1}, p_n, p_{n-1}] (Eqn (9), n ≥ 1)\n\np_n = [ân, b̂n, ĉn]  ⋅  [p'_{n+1}, p'_n, p'_{n-1}] (Eqn (19))\n\nx⋅p'_n  = [αᴵn, βᴵn, γᴵn] ⋅  [p'_{n+1}, p'_n, p'_{n-1}] (Eqn  (14))\n\nUsing (7), Clenshaw polynomial evaluation using the three  point recursion is defined.\n\nUsing (19), expressions for derivatives are found.\n\nUsing  (19), expressions for integration are found (p7).\n\nUsing their theorems 2,4, and 5, connection coefficients, C(n,m) satisfying  P_n(x) =  ∑  C(n,m)  Q_m(x) (n ≥ 0, 0 ≤  m ≤ n) are  found. These  allow  fallback  definitions for convert(Polynomial,p),  convert(P, p::Polynomial), convert(P{α…}, p::P(β…)) and through composition polynomial  multiplication,  p*q.\n\nSubtypes of AbstractCCOP are  created through  the @register0 or  @registerN macros, where the  N  macro  is used  if parameters are  needed to describe the family.\n\nIf non-monic versions are desired, then the  leading  term can be  specified through kn() (which by default is defined by the  method k1k0(P,i), the ratio of  kᵢ₊₁/kᵢ).  The @register_monic macro is useful  for creating  monic versions through  method delegation from the common non-monic systems. Similarly, the @register_shifted macro is useful  to provide shifted versions (cf. ShiftedLegendre).\n\nRegistering a system, defining an abcde method, and optionally defining k1k0 is usually sufficient to define a new system, though the general equations may need specializations when algebraic cancellation is required.\n\nThe defaults for evaluation and multplication are generally an order of magnitude slower than a directly defined function. For some families this is done (e.g. Chebyshev,ChebyshevU, Hermite, Laguerre), but not all.\n\nExample\n\nFor this example, the value of Bn at 0 needs help:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> SP.@register0 MonicLegendre′ SP.AbstractCCOP0\n\njulia> SP.:ϟ(::Type{<:MonicLegendre′}) = Legendre\n\njulia> SP.@register_monic MonicLegendre′  # use  ϟ to delegate methods\n\njulia> 𝐐  =  Rational{Int}\nRational{Int64}\n\njulia> x = variable(Polynomial{𝐐})\nPolynomial(x)\n\njulia> [basis(MonicLegendre′{𝐐}, i)(x) for i  in 0:5]\n6-element Array{Polynomial{Rational{Int64}},1}:\n Polynomial(1//1)\n Polynomial(x)\n Polynomial(-1//3 + x^2)\n Polynomial(-3//5*x + x^3)\n Polynomial(3//35 - 6//7*x^2 + x^4)\n Polynomial(5//21*x - 10//9*x^3 + x^5)\n\nKoekoek and Swarttouw present an encyclopedia of formula characterizing families of orthogonal polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.AbstractCDOP","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractCDOP","text":" AbstractCDOP{T,N} <: AbstractCOP{T,N}\n\nFollowing Koepf  and Schmersau, a family y(x)=p_n(x)=k_x⋅x^n +  ...   for  n  ∈  {0, 1,…}, k_n ≠ 0 of polynomials is a family of classic discrete orthogonal polynomials if it  is  a solution of a differential equation\n\n(a⋅x²+b⋅x+c) ⋅ Δ∇y + (d⋅x + e) ⋅ ∇' + λᵢ⋅ y = 0,\n\nwhere  Δy(x) = y(x+1) - y(x) and ∇y(x) = y(x) - y(x-1).\n\nA family is characterized by the 5 coefficients: a,b,c,d,e. Let σ = (a⋅x²+b⋅x+c), τ = (d⋅x + e).\n\nAs in the classical-continuous-orthogonal-polynomial case AbstractCCOP, from these 5 values the cofficients in the there-point recursion, and other structural equations can be represented. These allow polynomial multiplication, integration, differentiation, conversion, etc. to be defined generically.\n\nKoekoek and Swarttouw present an encyclopedia of formula characterizing families of orthogonal polynomials. \n\nFor example, on p29 they give  formulas for Hahn polynomials through:\n\nn(n+α+β+1)y(x) = B(x)y(x+1) -[B(x)+D(x)]y(x) + D(x)y(x-1),  with  explicit values  for  B and D. Reexpressing gives: BΔy(x) - D∇y(x) -λ y(x)  = 0. From the rexpressed Eqn (4) for Koepf & Schemersau we have the identification: σ+τ =  B; σ=D,  so  τ=B-D. From this a,b,c,d,e can be  gleaned.\n\nThe above, is termed the eigevalue equation (e.g. Goertz and Offner), as it can be reexpressed as \n\nΔ(D(x)⋅ω(x)⋅∇yᵢ(x) = λᵢ⋅ω(x)⋅yᵢ(x)\n\n\n\n\n\n","category":"type"},{"location":"#Implemented-polynomial-types-1","page":"SpecialPolynomials.jl","title":"Implemented polynomial  types","text":"","category":"section"},{"location":"#Classical-continuous-orthogonal-polynomials-1","page":"SpecialPolynomials.jl","title":"Classical continuous orthogonal polynomials","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"There are  several classical continuous  orthogonal polynomials available:","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Legendre\nChebyshev\nChebyshevU\nLaguerre\nHermite\nChebyshevHermite\nGegenbauer\nJacobi\nBessel\nShiftedLegendre","category":"page"},{"location":"#SpecialPolynomials.Legendre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Legendre","text":"Legendre{T}\n\nImplements the Legendre polynomials. These have weight function w(x) = 1 over the domain [-1,1].\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Legendre([1,2,3])\nLegendre(1⋅P₀(x) + 2⋅P₁(x) + 3⋅P₂(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-0.5 + 2.0*x + 4.5*x^2)\n\njulia> p2m, p2m1 = basis.(Legendre, (8,9)) # evaluation P_{2m+k}(-1) =  (-1)^k\n(Legendre(1.0⋅P₈(x)), Legendre(1.0⋅P₉(x)))\n\njulia> p2m(-1) == 1\nfalse\n\njulia> p2m1(-1) == -1\nfalse\n\njulia> n = 5  # verify  Rodrigues' formula \n5\n\njulia> x = Polynomial(:x)\nPolynomial(x)\n\njulia> derivative((x^2-1)^n, n) - 2^n *  factorial(n) * basis(Legendre, n)\nPolynomial(1.8189894035458565e-12*x)\n\njulia> p4, p5  =  basis.(Legendre, (4,5)) # verify  orthogonality  of  P₄,P₅\n(Legendre(1.0⋅P₄(x)), Legendre(1.0⋅P₅(x)))\n\njulia> SpecialPolynomials.innerproduct(Legendre, p4,  p5)\n-1.543670556388031e-16\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Chebyshev","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Chebyshev","text":"Chebyshev{<:Number}(coeffs::AbstractVector, var=:x)\n\nChebyshev polynomial of the first kind.\n\nConstruct a polynomial from its coefficients a, lowest order first, optionally in terms of the given variable x. x can be a character, symbol, or string.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> Chebyshev([1, 0, 3, 4])\nChebyshev(1⋅T₀(x) + 3⋅T₂(x) + 4⋅T₃(x))\n\njulia> Chebyshev([1, 2, 3, 0], :s)\nChebyshev(1⋅T₀(s) + 2⋅T₁(s) + 3⋅T₂(s))\n\njulia> one(Chebyshev)\nChebyshev(1.0⋅T₀(x))\n\nnote: Note\nThis is copied from the ChebyshevT example from the Polynomials package by Miles Lucas.\n\nnote: Note\nThe sample chapter available online of Numerical Methods for Special Functions\" by Amparo Gil, Javier Segura, and Nico Temme gives a very nice overview of these polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ChebyshevU","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ChebyshevU","text":"ChebyshevU{T}\n\nImplements the Chebyshev polynomials of the second kind. These have weight function  w(x) = sqrt(1-x^2) over the domain [-1,1].\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = ChebyshevU([1,2,3])\nChebyshevU(1⋅U₀(x) + 2⋅U₁(x) + 3⋅U₂(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-2 + 4*x + 12*x^2)\n\njulia> derivative(p)\nChebyshevU(4.0⋅U₀(x) + 12.0⋅U₁(x))\n\njulia> roots(p)\n2-element Array{Float64,1}:\n -0.6076252185107651\n  0.27429188517743175\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Laguerre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Laguerre","text":"Laguerre{α, T <: Number}\n\nThe  Laguerre polynomials have weight function x^α * exp(-x) over the domain [0, oo). The parameter α is specified through the constructor.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Laguerre{1/2}([1,2,3])\nLaguerre{0.5}(1⋅Lᵅ₀(x) + 2⋅Lᵅ₁(x) + 3⋅Lᵅ₂(x))\n\njulia> convert(Polynomial, p)\nPolynomial(9.625 - 9.5*x + 1.5*x^2)\n\nThe Laguerre polynomials are the case α=0.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Laguerre{0}([1,2,3])\nLaguerre{0}(1⋅L₀(x) + 2⋅L₁(x) + 3⋅L₂(x))\n\njulia> convert(Polynomial, p)\nPolynomial(6.0 - 8.0*x + 1.5*x^2)\n\njulia> phi(u, i) = derivative(u) -  u # verify Rodrigues' formula for small n; n! L_n = (d/dx-1)^n x^n\nphi (generic function with 1 method)\n\njulia> x = Polynomial(:x)\nPolynomial(x)\n\njulia> n = 7\n7\n\njulia> factorial(n) * basis(Laguerre{0}, n) - foldl(phi, 1:n, init=x^n)\nPolynomial(-5.4569682106375694e-12 + 1.4551915228366852e-11*x - 7.275957614183426e-12*x^2)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Hermite","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Hermite","text":"Hermite\n\nThe Hermite polynomials have two versions the physicists (Hermite  or  H) and the probablalists (ChebyshevHermite or  Hₑ). They are  related through  Hᵢ(x) =  2^(i/2) Hₑᵢ(√2 x).\n\nThe Hermite   polynomials have weight  function w(x)=exp(-x^2/2) and domain the real line.\n\nExamples\n\njulia> using Polynomials,  SpecialPolynomials\n\njulia> x = variable(Polynomial{Rational{Int}})\nPolynomial(x)\n\njulia> [basis(Hermite, i)(x) for i in 0:5]\n6-element Array{Polynomial{Float64},1}:\n Polynomial(1.0)\n Polynomial(2.0*x)\n Polynomial(-2.0 + 4.0*x^2)\n Polynomial(-12.0*x + 8.0*x^3)\n Polynomial(12.0 - 48.0*x^2 + 16.0*x^4)\n Polynomial(120.0*x - 160.0*x^3 + 32.0*x^5)\n\njulia> [basis(ChebyshevHermite, i)(x) for i in 0:5]\n6-element Array{Polynomial{Float64},1}:\n Polynomial(1.0)\n Polynomial(1.0*x)\n Polynomial(-1.0 + 1.0*x^2)\n Polynomial(-3.0*x + 1.0*x^3)\n Polynomial(3.0 - 6.0*x^2 + 1.0*x^4)\n Polynomial(15.0*x - 10.0*x^3 + 1.0*x^5)\n\nnote: Note\nThe Hermite family needs help, as the computed values for Bn,and,Cn are  both 0.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ChebyshevHermite","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ChebyshevHermite","text":"ChebyshevHermite\n\nType for the Probabalist's  Hermite polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Gegenbauer","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Gegenbauer","text":"Gegenbauer{α, T <: Number}\n\nThe Gegenbauer polynomials have weight function (1-x^2)^(α-1/2) over the domain [-1,1]. The parameter α is specified in the constructor. These are also called the ultra-spherical polynomials. The Legendre polynomials are the specialization  Gegenbauer{1/2}.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p =  Gegenbauer{1/2}([1,2,3])\nGegenbauer{0.5}(1⋅Cᵅ₀(x) + 2⋅Cᵅ₁(x) + 3⋅Cᵅ₂(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-0.5 + 2.0*x + 4.5*x^2)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Jacobi","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Jacobi","text":"Jacobi{α,  β, T}\n\nImplements the Jacobi polynomials. These have weight function w(x) = (1-x)^α ⋅ (1+x)^β over the domain [-1,1]. Many orthogonal polynomial types are special cases. The parameters are  specified to the constructors:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Jacobi{-1/2, -1/2}([0,0,1])\nJacobi{-0.5,-0.5}(1⋅Jᵅᵝ₂(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-0.375 + 0.75*x^2)\n\njulia> monic(p) = (q=convert(Polynomial,p); q/q[end])\nmonic (generic function with 1 method)\n\njulia> monic(p) ≈  monic(basis(Chebyshev, 2))\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Bessel","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bessel","text":"Bessel{α}\n\nImplements the Bessel polynomials, introduced by Krall and Frink (with b=2). The  case a=2 corresponds to the  Bessel polynomials of Wikipedia. The Bessel  polynomials are not orthogonal over  a domain of the real  line, rather over an arbitray curve in the complex plane enclosing the  origin.  The weight  function is ρ(x)=(2πi)^(-1)∑Γ(α)/Γ(α+n-1)(-β/x)^n,   where β=2.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> 𝐐 = Rational{Int}\nRational{Int64}\n\njulia> x = variable(Polynomial{𝐐})\nPolynomial(x)\n\njulia> [basis(Bessel{3//2, 𝐐}, i)(x) for i in 0:5]\n6-element Array{Polynomial{Rational{Int64}},1}:\n Polynomial(1//1)\n Polynomial(1//1 + 3//4*x)\n Polynomial(1//1 + 5//2*x + 35//16*x^2)\n Polynomial(1//1 + 21//4*x + 189//16*x^2 + 693//64*x^3)\n Polynomial(1//1 + 9//1*x + 297//8*x^2 + 1287//16*x^3 + 19305//256*x^4)\n Polynomial(1//1 + 55//4*x + 715//8*x^2 + 10725//32*x^3 + 182325//256*x^4 + 692835//1024*x^5)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ShiftedLegendre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ShiftedLegendre","text":"ShiftedLegendre\n\nType for the shifted Legendre polynomials: Pˢᵢ(x) =  Pᵢ(2x-1) for x ∈ [0,1].\n\n\n\n\n\n","category":"type"},{"location":"#Classical-discrete-orthogonal-polynomials-1","page":"SpecialPolynomials.jl","title":"Classical discrete orthogonal polynomials","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"There are  several classical discrete  orthogonal polynomials available:","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Charlier\nKrawchouk\nMeixner\nHahn\nDiscreteChebyshev\nFallingFactorial","category":"page"},{"location":"#SpecialPolynomials.Charlier","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Charlier","text":"Charlier{μ}\n\nReferences: Koekoek and Swarttouw §1.12\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Krawchouk","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Krawchouk","text":" Krawchouk{p,𝐍}\n\nAlso spelled  Krawtchouk,  Kravhcuk,….\n\nReferences: Koekoek and Swarttouw §1.10;  see  also  Coleman for a different  parameterization.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Meixner","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Meixner","text":"Meixner{γ,μ}\n\nReferences: Koekoek and Swarttouw §1.9\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Hahn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Hahn","text":"Hahn{α,β,𝐍}\n\nReferences: Koekoek and Swarttouw §1.5\n\nnote: Note\nIn  Koekoek and Swarttouw sections 1.3, 1.4, and 1.6  are other  Hahn-type polynomials,  not  implemented here.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.DiscreteChebyshev","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.DiscreteChebyshev","text":"DiscreteChebyshev\n\nThis uses p22 of   to define a two-parameter  family of non orthogonal polynomials. See  the example  in DiscreteWeightFunction for implementing  the DiscreteChebyshev  polynomials  from Wikipedia.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> import SpecialPolynomials: Δₓ, ∇ₓ\n\njulia> α,β = 1/2, 1\n(0.5, 1)\n\njulia> P  = DiscreteChebyshev{α,β}\nDiscreteChebyshev{0.5,1,T,N} where N where T\n\njulia> i = 5\n5\n\njulia> yᵢ = basis(P, i)\nDiscreteChebyshev(1.0⋅K⁽ᵅᵝ⁾₅(x))\n\njulia> x = variable(P)\nDiscreteChebyshev(- 2.0⋅K⁽ᵅᵝ⁾₀(x) + 2.0⋅K⁽ᵅᵝ⁾₁(x))\n\njulia> a,b,c,d,e = SpecialPolynomials.abcde(P)\n(a = 0, b = 0, c = 1, d = 0.5, e = 1)\n\njulia> λᵢ  = -(a*i*(i-1)  + d*i)\n-2.5\n\njulia> Δₓ(∇ₓ(yᵢ)) +  (α*x + β) * Δₓ(yᵢ) ≈ -λᵢ*yᵢ # p22: \"are not orthogonal, but satisfy the difference equation...\"\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.FallingFactorial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.FallingFactorial","text":"FallingFactorial{T}\n\nConstruct  a  polynomial with   respect to the basis x⁰̲,  x¹̲, x²̲, … where  xⁱ̲ = x  ⋅  (x-1) ⋅  (x-2)  ⋯ (x-i+1) is the falling Pochhammer  symbol.  See  Falling factorial  for several  facts about this  polynomial basis.\n\nIn Koepf and Schmersau connection coefficients between the falling factorial polynomial system and classical discrete orthogonal polynomials are given.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = basis(FallingFactorial, 3)\nFallingFactorial(1.0⋅x³̲)\n\njulia> x = variable(Polynomial)\nPolynomial(x)\n\njulia> p(x) ≈ x*(x-1)*(x-2)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Some non-exported methods are available or define each of  the classical orthogonal polynomials:","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.weight_function\nSpecialPolynomials.generating_function\nSpecialPolynomials.abcde\nSpecialPolynomials.An\nSpecialPolynomials.Bn\nSpecialPolynomials.Cn\nSpecialPolynomials.jacobi_matrix\nSpecialPolynomials.gauss_nodes_weights","category":"page"},{"location":"#SpecialPolynomials.weight_function","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.weight_function","text":"weight_function(p)\nweight_function(::Type{P})\n\nFor an orthogonal polynomial type, a function w with ∫ B_n(t) B_m(t) w(t) dt = 0 when n and m are not equal.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.generating_function","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.generating_function","text":"generating_function(p)\ngenerating_function(::Type{P})\n\nThe generating function is a function defined by: (t,x) -> sum(t^n Pn(x) for n in 0:oo).\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.abcde","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.abcde","text":"abcde\n\nA named tuple returning  the  constants a,b,c,d,e  for a CCOP type with (a⋅x²+b⋅x+c)*P₍ᵢ₊₂₎'' + (d⋅x + e) * P₍ᵢ₊₁₎ + λᵢ Pᵢ = 0.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.An","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.An","text":"An(::Type{P},n)\n\nOrthogonal polynomials defined by a weight function satisfy a three point recursion formula of the form:\n\nP_{n+1} = (A_n x + B_n) P_{n} - C_n P_{n-1}\n\nIf the polynomials are monic, this is usually parameterized as:\n\nπ_{n+1} = (x - α̃_n) π_n - β̃_n π_{n-1}\n\nThese functions are used through recursion when evaluating the polynomials, converting to Polynomial format, for constructing the Vandermonde matrix, for construction the Jacobi matrix, and elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.Bn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bn","text":"Bn(::Type{P},n)\nBn(p::P, n)\n\ncf. An()\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.Cn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Cn","text":"Cn(::Type{P},n)\nCn(p::P, n)\n\ncf. An()\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.jacobi_matrix","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jacobi_matrix","text":"jacobi_matrix(::Type{P}, n)\n\nThe Jacobi Matrix is a symmetric tri-diagonal matrix. The diagonal entries are the alpha_i values, the off diagonal entries, the square root of the  beta_i values. This matrix has the properties that\n\nthe eigenvalues are the roots of the corresponding basis vector. As these roots are important in quadrature, and finding eigenvalues of a symmetric tri-diagonal matrix yields less error than finding the eigenvalues of the companion matrix, this can be used for higher degree basis polynomials.\nthe normalized eigenvectors have initial term proportional to the weights in a quadrature formula\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.gauss_nodes_weights","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.gauss_nodes_weights","text":"gauss_nodes_weights(::Type{P}, n)\n\nReturns a tuple of nodes and weights for Gauss quadrature for the given orthogonal type.\n\nFor some types, a method from  A. Glaser, X. Liu, and V. Rokhlin. \"A fast algorithm for the calculation of the roots of special functions.\" SIAM J. Sci. Comput., 29 (2007), 1420-1438. is used. \n\nFor others the Jacobi matrix, Jn, for which the Golub-Welsch] algorithm The nodes  are computed from the eigenvalues of Jn, the weights a scaling of the first component of the normalized eigen vectors (β_0 * [v[1] for v in vs])\n\nnote: Note\nSee the FastGaussQuadrature package for faster, vastly more engineered implementations.\n\n\n\n\n\n","category":"function"},{"location":"#Defining-new-types-1","page":"SpecialPolynomials.jl","title":"Defining new types","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"A new polynomial system  of classical type can  be specified fairly  succinctly,  provided the 5 constants  for the  abcde  method are known.","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Polynomial systems  can also be generated  through  an associated weight function.","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"WeightFunction\nDiscreteWeightFunction","category":"page"},{"location":"#SpecialPolynomials.WeightFunction","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.WeightFunction","text":"WeightFunction{T}\n\nA type for orthogonal polynomials relative to some weight function. The Wheeler or modified Chebyshev algorithm (Gautschi, Press and Teukolsky) is used to generate the three-term recurrence relation. \n\nIf the second order differential equation, σ⋅p'' + τ⋅p' + λ⋅p=- is known, using that to define the polynomial type would be preferred, as then several additional properties follow for free.\n\nThe key computation is the modified moment, ∫πⱼ dw where πⱼ is the jth basis vector for an associated monic system, P, and w is the weight function.  These values are registered through the @register_weight_function(Type, P, w) macro, as illustrated in the examples.\n\nExample.\n\nToy example with ChebyshevU being derived using the  Chebyshev system.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP = SpecialPolynomials\nSpecialPolynomials\n\njulia> SP.@register0 Toy SP.WeightFunction   # register a  Toy  example\n\njulia> SP.@register_weight_function Toy MonicChebyshev SP.weight_function(ChebyshevU)\n\njulia> [SP.Cn.(Toy, 1:5) SP.Cn.(MonicChebyshevU, 1:5)]\n5×2 Array{Float64,2}:\n 0.25  0.25\n 0.25  0.25\n 0.25  0.25\n 0.25  0.25\n 0.25  0.25\n\nElliptic orthogonal polynomials on  [-1,1]. Demo 2 of Gautschi.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> N,  ω² = 40, 0.999\n(40, 0.999)\n\njulia> w(t) = ((1-ω²*t^2)*(1-t^2))^(-1/2)\nw (generic function with 1 method)\n\njulia> SP.@register0 WF SP.WeightFunction\n\njulia> SP.@register_weight_function WF MonicChebyshev w\n\njulia> αs, βs = -SP.Bn.(WF, 0:5), SP.Cn.(WF, 0:5);\n\njulia> [αs βs]\n6×2 Array{Float64,2}:\n -1.87309e-15  9.68226\n  2.35136e-15  0.793782\n -8.51176e-16  0.119868\n -3.06017e-15  0.22704\n -3.09826e-16  0.241061\n  2.37296e-15  0.245429\n\nThe main computation involved in this is the modified moment, νⱼ = ∫πⱼ dw, computed with QuadGK.quadgk. For some examples, this computation can be completed directly and the modified_moment method may be overloaded for the type. This example is from Press and Teukolsky, where the modified moments are given through the function v(j) defined below.\n\njulia> using Polynomials, SpecialPolynomials, SpecialFunctions\n\njulia> const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> w(t) = -log(t)\nw (generic function with 1 method)\n\njulia> SP.@register0 WF1 SP.WeightFunction   #  register  type WF1 as a weight function\n\njulia> SP.@register_weight_function WF1  MonicShiftedLegendre w\n\njulia> ν(j) = iszero(j) ? 1 : (-1)^j * gamma(j+1)^2 / (j*(j+1)*gamma(2j+1)) # help  out\nν (generic function with 1 method)\n\njulia> SP.modified_moment(::Type{WF1},  j::Int) = ν(j)\n\njulia> αs, βs = -SP.Bn.(WF1, 0:5), SP.Cn.(WF1, 0:5);\n\njulia> [αs βs]\n6×2 Array{Float64,2}:\n -0.75      1.0\n -0.381148  0.423611\n -0.504058  0.172646\n -0.516236  0.203166\n -0.517168  0.222419\n -0.513854  0.239667\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.DiscreteWeightFunction","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.DiscreteWeightFunction","text":"DiscreteWeightFunction\n\nFor a discrete measure, dλ = ∑ wᵢ δ(x - xᵢ), specified through two vectors, xs and ws, a collection of monic orthogonal polynomials is produced through Darboux's formula for α_n and β_n using the 3-term recurrence defined by π_{n+1} = (x-α_n)⋅π_n - β_n⋅π_{n-1} (An=1, Bn=-α_n, Cn=β_n) and the discrete Stieltjes method Guatschi §3.1.\n\nExample\n\nDiscrete Chebyshev by its weight function (uniform  on 0,1,…,N-1)\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP = SpecialPolynomials;\n\njulia> N = 9\n9\n\njulia> xs, ws = collect(0:N-1), ones(N);   # w(x) = ∑ wⱼ⋅δ(x-xⱼ)\n\njulia> SP.@register0 DWF DiscreteWeightFunction\n\njulia> SP.@register_discrete_weight_function(DWF, xs, ws)\n\njulia> [SP.Bn.(DWF, 0:N-1) SP.Cn.(DWF, 0:N-1)]\n9×2 Array{Float64,2}:\n -4.0  9.0\n -4.0  6.66667\n -4.0  5.13333\n -4.0  4.62857\n -4.0  4.12698\n -4.0  3.53535\n -4.0  2.83217\n -4.0  2.01026\n -4.0  1.06667\n\njulia> i,j = 3,4; ## check  that ∫pᵢpⱼdw  = 0    for i,j=3,4\n\njulia> sum(basis(DWF,i)(x) *  basis(DWF,j)(x) * w for  (x,w) in zip(xs, ws))\n5.684341886080802e-14\n\njulia> ## Gogin, Hirvensalo (https://doi.org/10.1007/s10958-017-3410-8) characterization\n       D(k,N,x) =  sum((-1)^l * binomial(k+l,k) * binomial(N-l,k-l) *  SP.generalized_binomial(x,l) for l in 0:k)\nD (generic function with 1 method)\n\njulia> x = variable()\nPolynomial(x)\n\njulia> ps,qs = [D(k,N-1,x)  for  k in 0:N-1], [basis(DWF, k)(x) for k  in 0:N-1];\n\n\n\njulia> all(qs .* [p[end] for p  in ps] .≈ ps)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Interpolating-polynomials-1","page":"SpecialPolynomials.jl","title":"Interpolating polynomials","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractInterpolatingPolynomial","category":"page"},{"location":"#SpecialPolynomials.AbstractInterpolatingPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractInterpolatingPolynomial","text":"AbstractInterpolatingPolynomial{T}\n\nAbstract type for interpolating polynomials.\n\nThese are polynomial representations of p(x) satisfying p(x_i) = y_i for a specified set of x values and y values.\n\nFor a collection of points (x_0,y_0), ..., (x_n, y_n) there is a unique polynomial of degree n or less satisfying p(x_i)=y_i. This fact allows the specification of p(x) using a vector of coefficients relative to some set of basis vectors.\n\nThe two main types, Lagrange and Newton, store the nodes within the instance. In particular, the type does not contain all the information needed to describe the family. So methods like convert(::Type, p) will not work. Use fit(Type, xs, p), as appropriate, instead.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Lagrange\nNewton","category":"page"},{"location":"#SpecialPolynomials.Lagrange","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Lagrange","text":"Lagrange{N, S, R, T}\n\nRepresent a polynomial in Lagrange form using nodes xs, weights ws, and coefficients coeffs. The Lagrange form does polynomial interpolation between xs and ys through p(x) = Σ_{0..n} ℓ_i(x) y_i, where if ℓ(x) = prod(x-x_i), w_i = 1/prod_{j≠i}(x_i - x_j), then ℓ_i(x) = ℓ(x) w_i/(x-x_i). The ℓ_i satisfy ℓ_i(x_j) = δ_{ij}, so the coefficients are just the ys.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p =  Lagrange([1,2,3], [1,2,3])\nLagrange(1⋅ℓ^2_0(x) + 2⋅ℓ^2_1(x) + 3⋅ℓ^2_2(x))\n\njulia> p.([1,2,3]) # the coefficients\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> convert(Polynomial,  p)\nPolynomial(1.0*x)\n\nThe instances hold the nodes and weights, which are necessary for representation, so the type alone can not be used for functions such as variable or convert(Lagrange, ...). For the former we can  use an instance, for the latter we can use fit:\n\njulia> p =  Lagrange([1,2,3], [1,2,3])\nLagrange(1⋅ℓ^2_0(x) + 2⋅ℓ^2_1(x) + 3⋅ℓ^2_2(x))\n\njulia> variable(p)\nLagrange(1⋅ℓ^2_0(x) + 2⋅ℓ^2_1(x) + 3⋅ℓ^2_2(x))\n\njulia> q = Polynomial([0,0,1])\nPolynomial(x^2)\n\njulia> qq = fit(Lagrange, p.xs, q)\nLagrange(1⋅ℓ^2_0(x) + 4⋅ℓ^2_1(x) + 9⋅ℓ^2_2(x))\n\njulia> convert(Polynomial, qq)\nPolynomial(1.0*x^2)\n\nInterpolating polynomials suffer from the Runge phenomenon unless the nodes are well chosen. For P=Chebyshvev and P=ChebyshevU, the function SpecialPolynomials.lagrange_barycentric_nodes_weights(P, n) will return a good choice of n+1 points over [-1,1] along with precomputed weights. \n\njulia> xs, ws = SpecialPolynomials.lagrange_barycentric_nodes_weights(Chebyshev, 64);\n\n\njulia> f(x) = exp(-x)*sinpi(x)\nf (generic function with 1 method)\n\njulia> p = fit(Lagrange, xs, f.(xs));\n\n\njulia> degree(p)\n64\n\njulia> maximum(abs.(f(x) - p(x) for x in range(-1, 1, length=20))) <= 1e-14\ntrue\n\nnote: Note\nThe above example  is  more directly  done through fit(Chebyshev, f, 64), though  the resulting polynomial will reference a different  basis.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Newton","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Newton","text":"Newton{S,T}\n\nA Newton interpolating polynomial uses a basis 1, (x-x_0), (x-x_0)(x-x_1), ..., (x-x0)(x-x1)⋅⋅⋅(x-x_{n-1}) and coefficients (in forward form) f[x_0], f[x_0,x_1], ...,f[x_0,...,x_n]. The Newton class stores the nodes (after sorting) and the Newton tableau used to generate the coefficients on fitting.\n\nThe easiest way to construct an instance is with fit, as in:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> xs = [1,2,3,4]; f(x)= x^3 - 2x + 1;\n\njulia> p = fit(Newton, xs, f)\nNewton(5.0⋅p_1(x) + 6.0⋅p_2(x) + 1.0⋅p_3(x))\n\njulia> p.(xs) == f.(xs)  # p interpolates\ntrue\n\njulia> convert(Polynomial, p)\nPolynomial(1.0 - 2.0*x + 1.0*x^3)\n\n\n\n\n\n","category":"type"},{"location":"#Other-polynomials-1","page":"SpecialPolynomials.jl","title":"Other polynomials","text":"","category":"section"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Bernstein","category":"page"},{"location":"#SpecialPolynomials.Bernstein","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bernstein","text":"Bernstein{N, T}\n\nA Bernstein  polynomial is a polynomial expressed in terms of Bernstein basic polynomials. For each degree, 𝐍, this is a set of 𝐍+1 degree 𝐍 polynomials of the form: β_{𝐍,ν} =  (ν choose 𝐍) x^ν  (1-x)^{𝐍-ν}, 0 ≤ x ≤ 1.\n\nThe Bernstein{𝐍,T} type represents a polynomial of degree 𝐍 or less with a linear combination of the basis vectors using coefficients of type T.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = basis(Bernstein{3},  2)\nBernstein(1.0⋅β₃,₂(x))\n\njulia> convert(Polynomial, p)\nPolynomial(3.0*x^2 - 3.0*x^3)\n\nnote: Note\nStaticUnivariatePolynomials Offers a  more  performant version.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Example of a Bezier curve  (parameterized by r(t) = ∑₀ᴺ bᵢBᵢ(t):","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"using Plots, Polynomials, SpecialPolynomials\nbs =[[220, 260], [220, 40], [35, 100],  [120, 140]]\nN = length(bs)-1\n\nρ = sum(bᵢ.*basis(Bernstein{N},i-1) for (i,bᵢ)  ∈ enumerate(bs))\nts = range(0, stop=1, length=500)\np =  plot(ρ[1].(ts), ρ[2].(ts), legend=false)\nscatter!(p, [b[1] for b in bs], [b[2] for b in bs])\nsavefig(\"bezier.svg\"); nothing # hide","category":"page"},{"location":"#","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"(Image: )","category":"page"}]
}
